<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzxzzxzzx123.github.io/zhang3.github.io/</id>
    <title>张卓欣的学习记录</title>
    <updated>2021-04-20T13:29:35.429Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzxzzxzzx123.github.io/zhang3.github.io/"/>
    <link rel="self" href="https://zzxzzxzzx123.github.io/zhang3.github.io/atom.xml"/>
    <subtitle>学习使我快乐</subtitle>
    <logo>https://zzxzzxzzx123.github.io/zhang3.github.io/images/avatar.png</logo>
    <icon>https://zzxzzxzzx123.github.io/zhang3.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 张卓欣的学习记录</rights>
    <entry>
        <title type="html"><![CDATA[小程序相关]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/xiao-cheng-xu-xiang-guan/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/xiao-cheng-xu-xiang-guan/">
        </link>
        <updated>2021-04-20T13:29:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-数据绑定">1.  数据绑定</h2>
<ol>
<li>小程序
<ol>
<li>data中初始化数据</li>
<li>修改数据： this.setData()
<ol>
<li>修改数据的行为始终是同步的</li>
</ol>
</li>
<li>数据流：
<ol>
<li>单项： Model ---&gt; View</li>
</ol>
</li>
</ol>
</li>
<li>Vue
<ol>
<li>data中初始化数据</li>
<li>修改数据: this.key = value</li>
<li>数据流：
<ol>
<li>Vue是单项数据流： Model ---&gt; View</li>
<li>Vue中实现了双向数据绑定： v-model</li>
</ol>
</li>
</ol>
</li>
<li>React
<ol>
<li>state中初始化状态数据</li>
<li>修改数据: this.setState()
<ol>
<li>自身钩子函数中(componentDidMount)异步的</li>
<li>非自身的钩子函数中(定时器的回调)同步的</li>
</ol>
</li>
<li>数据流：
<ol>
<li>单项： Model ---&gt; View</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-获取用户基本信息">2. 获取用户基本信息</h2>
<ol>
<li>用户未授权(首次登陆)
<ol>
<li>button open-type=‘getUserInfo’</li>
</ol>
</li>
<li>用户已经授权(再次登陆)
<ol>
<li>wx.getUserInfo</li>
</ol>
</li>
</ol>
<h2 id="3-前后端交互">3. 前后端交互</h2>
<ol>
<li>语法: wx.request()</li>
<li>注意点:
<ol>
<li>协议必须是https协议</li>
<li>一个接口最多配置20个域名</li>
<li>并发限制上限是10个</li>
<li><strong>开发过程中设置不校验合法域名</strong>： 开发工具 ---&gt; 右上角详情 ----&gt; 本地设置 ---&gt; 不校验</li>
</ol>
</li>
</ol>
<h2 id="4-本地存储">4. 本地存储</h2>
<ol>
<li>语法: wx.setStorage() || wx.setStorageSync() || .....</li>
<li>注意点：
<ol>
<li>建议存储的数据为json数据</li>
<li>单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</li>
<li>属于永久存储，同H5的localStorage一样</li>
</ol>
</li>
</ol>
<h1 id="扩展内容">扩展内容</h1>
<h2 id="1-事件流的三个阶段">1. 事件流的三个阶段</h2>
<ol>
<li>捕获: 从外向内</li>
<li>执行目标阶段</li>
<li>冒泡: 从内向外</li>
</ol>
<h2 id="2-事件委托">2. 事件委托</h2>
<ol>
<li>什么是事件委托
<ol>
<li>将子元素的事件委托(绑定)给父元素</li>
</ol>
</li>
<li>事件委托的好处
<ol>
<li>减少绑定的次数</li>
<li>后期新添加的元素也可以享用之前委托的事件</li>
</ol>
</li>
<li>事件委托的原理
<ol>
<li>冒泡</li>
</ol>
</li>
<li>触发事件的是谁
<ol>
<li>子元素</li>
</ol>
</li>
<li>如何找到触发事件的对象
<ol>
<li>event.target</li>
</ol>
</li>
<li>currentTarget VS target
<ol>
<li>currentTarget要求绑定事件的元素一定是触发事件的元素</li>
<li>target绑定事件的元素不一定是触发事件的元素</li>
</ol>
</li>
</ol>
<h2 id="3-定义事件相关">3. 定义事件相关</h2>
<ol>
<li>分类
<ol>
<li>标准DOM事件</li>
<li>自定义事件</li>
</ol>
</li>
<li>标准DOM事件
<ol>
<li>举例： click，input。。。</li>
<li>事件名固定的，事件由浏览器触发</li>
</ol>
</li>
<li>自定义事件
<ol>
<li>绑定事件
<ol>
<li>事件名</li>
<li>事件的回调</li>
<li>订阅方: PubSub.subscribe(事件名，事件的回调)</li>
<li>订阅方式接受数据的一方</li>
</ol>
</li>
<li>触发事件
<ol>
<li>事件名</li>
<li>提供事件参数对象， 等同于原生事件的event对象</li>
<li>发布方: PubSub.publish(事件名，提供的数据)</li>
<li>发布方是提供数据的一方</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Implicit super constructor Object() is undefined for default constructor. Must define an explicit   constructor错误]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/implicit-super-constructor-object-is-undefined-for-default-constructor-must-define-an-explicit-constructor-cuo-wu/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/implicit-super-constructor-object-is-undefined-for-default-constructor-must-define-an-explicit-constructor-cuo-wu/">
        </link>
        <updated>2021-04-19T13:07:49.000Z</updated>
        <summary type="html"><![CDATA[<p>今天在将另一台电脑上的javaee作业导入后class类出现问题-------Implicit super constructor Object() is undefined for default constructor. Must define an explicit   constructor错误</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天在将另一台电脑上的javaee作业导入后class类出现问题-------Implicit super constructor Object() is undefined for default constructor. Must define an explicit   constructor错误</p>
<!-- more -->
<p>创建Class类的时候突然出现冒红，为了让自己能长个记性我决定把这个问题写下来让自己能印象深刻。</p>
<p>解决方案：把java的类库加载进去，在工程上右键选择属性-&gt;Java Build Path的Libraries-&gt;Add Library选择JRE System Library-&gt;点击Next-&gt;选择Execution environment并选择jre版本或workspace default jre(有显示的版本不是都能选的的，只有默认自带的jre和安装绑定过的选了才能起作用，这里我选择的是JavaSE-1.8)-&gt;点击Finish。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序支持的背景文件格式]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/wei-xin-xiao-cheng-xu-zhi-chi-de-bei-jing-wen-jian-ge-shi/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/wei-xin-xiao-cheng-xu-zhi-chi-de-bei-jing-wen-jian-ge-shi/">
        </link>
        <updated>2021-04-10T11:49:06.000Z</updated>
        <summary type="html"><![CDATA[<p>今天我在一个微信小程序项目中看到了背景图片是一张gif图片😨</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天我在一个微信小程序项目中看到了背景图片是一张gif图片😨</p>
<!-- more -->
<p>于是我也想在自己的小程序中更改为.gif后缀的文件，在查询了官方文档后有下面解释</p>
<p>cover-image<br>
基础库 1.4.0 开始支持，低版本需做兼容处理。<br>
覆盖在原生组件之上的图片视图。可覆盖的原生组件同cover-view，支持嵌套在cover-view里。</p>
<figure data-type="image" tabindex="1"><img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1618055829123.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OSI七层模型与TCP/IP五层模型]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/osi-qi-ceng-mo-xing-yu-tcpip-wu-ceng-mo-xing/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/osi-qi-ceng-mo-xing-yu-tcpip-wu-ceng-mo-xing/">
        </link>
        <updated>2021-04-06T07:13:39.000Z</updated>
        <content type="html"><![CDATA[<p>1.OSI模型<br>
OSI全称为开放系统互联参考模型，于1978年被国际标准化组织（ISO）提出。OSI有七层，从低到高依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1617693646762.png" alt="" loading="lazy"><br>
&lt;1&gt;    应用层<br>
OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。<br>
&lt;2&gt;    表示层<br>
表示数据转换<br>
格式有，JPEG、ASCll、EBCDIC、加密格式等<br>
&lt;3&gt;    会话层<br>
建立、管理、终止会话。<br>
&lt;4&gt;   传输层<br>
定义传输数据的协议端口号，以及流控和差错校验。<br>
协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层<br>
&lt;5&gt;   网络层<br>
进行逻辑地址寻址，实现不同网络之间的路径选择。<br>
协议有：ICMP IGMP IP（IPV4 IPV6）<br>
&lt;6&gt;   数据链路层<br>
建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）<br>
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。<br>
&lt;7&gt;  物理层<br>
建立逻辑连接、进行硬件地址寻址、差错校验 [3]  等功能。（由底层网络定义协议）<br>
将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p>
<p>2.TCP/IP协议<br>
TCP/IP协议是个协议簇，它包含了多种协议。ISO/OSI模型、TCP/IP的分层模型及协议的对应如图<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1617694045715.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[The prefix "context" for element "context:component-scan" is not bound.]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/the-prefix-context-for-element-contextcomponent-scan-is-not-bound/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/the-prefix-context-for-element-contextcomponent-scan-is-not-bound/">
        </link>
        <updated>2021-03-29T13:14:42.000Z</updated>
        <content type="html"><![CDATA[<p>在配置Spring中的xml时配置<br>
&lt;context:component-scan base-package=&quot;包名&quot; /&gt;<br>
报错：The prefix &quot;context&quot; for element &quot;context:component-scan&quot; is not bound.</p>
<p>该配置文件的<beans></beans>标签的属性和当前的base.jar文件不匹配。需要在<beans>加上相应属性即可。如下图（红线上那一列即为需要加上的东西）：<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1617027281108.png" alt="" loading="lazy"></p>
<p>下面是需要添加的部分的文字版：<br>
xmlns：中加入<br>
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</p>
<p>xsi：中加入<br>
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql数据库驱动：mysql-connector-java-5.1.46-bin.jar]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/mysql-shu-ju-ku-qu-dong-mysql-connector-java-5146-binjar/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/mysql-shu-ju-ku-qu-dong-mysql-connector-java-5146-binjar/">
        </link>
        <updated>2021-03-29T13:10:59.000Z</updated>
        <summary type="html"><![CDATA[<p>今天在学习Spring的事务管理时要用到mysql-connector-java-bin.jar，<br>
我在百度找到下面的链接😀</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天在学习Spring的事务管理时要用到mysql-connector-java-bin.jar，<br>
我在百度找到下面的链接😀</p>
<!-- more -->
<p><a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.46.zip">mysql-connector-java-5.1.46-bin.jar 点击链接直接下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决代理产生的Failed to connect to 127.0.0.1 port 1080 Connection refused问题]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/jie-jue-dai-li-chan-sheng-de-failed-to-connect-to-127001-port-1080-connection-refused-wen-ti/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/jie-jue-dai-li-chan-sheng-de-failed-to-connect-to-127001-port-1080-connection-refused-wen-ti/">
        </link>
        <updated>2021-03-25T13:30:55.000Z</updated>
        <content type="html"><![CDATA[<p>今天在git clone项目时发现git拒绝连接，我在重启了好几次电脑仍然无法解决。后面才意识到是使用了proxy代理，所以要解决问题，还是要取消代理。</p>
<p>方式一：通过git取消代理设置<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1616679448569.png" alt="" loading="lazy"></p>
<p>方式二：<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1616679475812.png" alt="" loading="lazy"></p>
<p>方式三：<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1616679507357.png" alt="" loading="lazy"></p>
<p>把上面出现的所有使用代理的协议，全部都取消掉，然后再重新进行clone就解决问题了😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序入门概述]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/wei-xin-xiao-cheng-xu-ru-men-gai-shu/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/wei-xin-xiao-cheng-xu-ru-men-gai-shu/">
        </link>
        <updated>2021-03-23T14:11:02.000Z</updated>
        <summary type="html"><![CDATA[<p>小程序特点概述</p>
<p>1.没有DOM</p>
]]></summary>
        <content type="html"><![CDATA[<p>小程序特点概述</p>
<p>1.没有DOM</p>
<!-- more -->
<p>2.组件化开发：具备特定功能效果的代码集合</p>
<!-- more -->
<p>3.体积小，单个压缩包体积不能大于2M，否则无法上线</p>
<!-- more -->
<p>4.小程序的四个重要的文件<br>
​    a）*.js</p>
<p>​    b）*.wxml   view结构   html</p>
<p>​    c）*.wxss     view样式   css</p>
<p>​    d）*.json     view数据   json文件</p>
<!-- more -->
<p>5.小程序特有的适配方案//小程序虽然以html5为基础，但是使用中仍有差异<br>
​    a）小程序适配单位：rpx</p>
<p>​    b）规定任何屏幕下宽度为750rpx</p>
<p>​    c）小程序会根据屏幕的宽度不同自动计算rpx值的大小</p>
<p>6.小程序API</p>
<p>​    a）小程序全局对象是：wx</p>
<p>​    b）所有的API都保存在wx对象中</p>
<p>7.快速查找技巧</p>
<p>a）当在小程序中想要实现某一种布局，查看组件</p>
<p>b）当在小程序中想要实现某一种功能，查看API</p>
<p>c）当在小程序中想要实现某一个配置或者某一种页面语法，查看框架+指南</p>
<p>微信官方文档</p>
<!-- more -->
<p>https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html</p>
<p>8.常用API</p>
<p>界面交互：</p>
<p>显示消息提示框：wx.showToast（）<br>
显示消息加载框：wx.showLoading（）<br>
关闭消息提示框：wx.hideToast（）<br>
关闭消息加载框：wx.hideLoading（）</p>
<p>路由跳转<br>
wx.navigateTo（）<br>
wx.redirectTo（）<br>
wx.switchTab（）</p>
<p>网络请求<br>
wx.request（）</p>
<p>本地存储<br>
wx.setStorage（）<br>
wx.setStorageSync（）<br>
wx.getStorage（）<br>
wx.getStorageSync（）</p>
<p>媒体<br>
wx.getBackgroundAudioManager（）<br>
wx.playVoice（）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程和进程的区别]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/xian-cheng-he-jin-cheng-de-qu-bie/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/xian-cheng-he-jin-cheng-de-qu-bie/">
        </link>
        <updated>2021-03-20T09:20:51.000Z</updated>
        <content type="html"><![CDATA[<p>什么是进程和线程？😵<br>
进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p>
<p>线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p>
<p>一个程序至少一个进程，一个进程至少一个线程。</p>
<p>为什么会有线程？</p>
<p>每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p>
<p>线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来。<br>
进程分为单线程进程和多线程进程，单线程进程宏观来看也是线性执行过程，微观上只有单一的执行过程。多线程进程宏观是线性的，微观上多个执行操作。<br>
线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化。</p>
<p></p>
<p>线程和进程各自有什么区别和优劣呢？<br>
进程是资源分配的最小单位，线程是程序执行的最小单位。</p>
<p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p>
<p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p>
<p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>
<p>何时使用多进程，何时使用多线程？</p>
<p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</p>
<p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何应对高并发]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/ru-he-ying-dui-gao-bing-fa/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/ru-he-ying-dui-gao-bing-fa/">
        </link>
        <updated>2021-03-20T08:59:00.000Z</updated>
        <content type="html"><![CDATA[<p>高并发?</p>
<p>高并发是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
<p>高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。</p>
<p>响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p>
<p>吞吐量：单位时间内处理的请求数量。</p>
<p>QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>
<p>并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>
<p>处理高并发问题的常见方法有如下几种:</p>
<ol>
<li>使用静态页面<br>
尽量将可以使用静态页面的地方使用静态页面，减少页面的解析时间，能够缓解服务器压力并降低数据库数据的频繁交换。<br>
实现静态页面的方法由很多：</li>
</ol>
<p>freemarker<br>
Thymeleaf<br>
2.缓存方面<br>
将一些有时效性或经常访问的数据存储在专门用于缓存的应用程序中，减少数据库的访问压力。常见的缓存技术有：</p>
<p>本地缓存：Cache</p>
<p>分布式缓存：Redis</p>
<ol start="3">
<li>优化数据库方面(对于一个优秀的应用，sql优化是必须做的)</li>
</ol>
<p>优化数据库查询语句，复杂的SQL语句不要使用ORM框架自动生成而是手动编写，同时优化数据库的表结构，如加入索引等.<br>
数据库读写分离，主数据库服务器负责写，从数据库服务器负责读，通过主从复制来保证数据的完整性。<br>
分表分区<br>
对数据库服务器进行硬件升级<br>
表的设计要符合三大范式<br>
添加适当的存储过程,触发器和事务等.</p>
<p>4.负载均衡<br>
我们知道可以通过集群以支持高并发和大数据量，而集群之间的分工就需要依靠负载均衡技术。<br>
负载均衡是指将请求划分给多个操作单元也就是分开部署的服务器上，即将收到请求按照一定规则分发给其它专门处理的处理服务器进行处理</p>
<p>5.动静分离<br>
一般有两种：</p>
<p>图片服务器分离：因为请求访问服务器上的图片资源是非常耗费服务器资源的，所以我们可以单独部署图片服务器，将压力转移并分担风险。<br>
将静态资源全部存放在 CDN 服务器上或者 nginx 服务器上，提高用户访问静态代码的速度，降低对后台应用访问。<br>
CDN：能实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等信息将请求重新导向离用户最近的服务节点上。<br>
nginx：高性能的HTTP服务器和反向代理服务器</p>
<p>6.多用异步请求，少用同步请求。（需要返回结果执行下一步的必须使用同步请求）</p>
]]></content>
    </entry>
</feed>