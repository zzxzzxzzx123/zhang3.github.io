<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzxzzxzzx123.github.io/zhang3.github.io/</id>
    <title>张卓欣的学习记录</title>
    <updated>2021-12-10T04:23:48.828Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzxzzxzzx123.github.io/zhang3.github.io/"/>
    <link rel="self" href="https://zzxzzxzzx123.github.io/zhang3.github.io/atom.xml"/>
    <subtitle>学习使我快乐</subtitle>
    <logo>https://zzxzzxzzx123.github.io/zhang3.github.io/images/avatar.png</logo>
    <icon>https://zzxzzxzzx123.github.io/zhang3.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 张卓欣的学习记录</rights>
    <entry>
        <title type="html"><![CDATA[一个Android中事件分发的问题]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/yi-ge-android-zhong-shi-jian-fen-fa-de-wen-ti/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/yi-ge-android-zhong-shi-jian-fen-fa-de-wen-ti/">
        </link>
        <updated>2021-12-10T04:22:15.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://images2015.cnblogs.com/blog/759818/201604/759818-20160411125425113-526042581.png" alt="img" loading="lazy"></figure>
<p>一个LinerLayout里放一个Button，当点击Button的时候事件是怎么传递的？</p>
<figure data-type="image" tabindex="2"><img src="https://images2015.cnblogs.com/blog/759818/201604/759818-20160411125425566-1337249448.png" alt="img" loading="lazy"></figure>
<p>点击事件用MotionEvent来表示，当点击事件发生时，最先传递给Activity，用Activity的dispatchTouchEvent来进行事件的派发，具体的工作是用Activity内部的Window来完成的。Window将事件传递个decor view，decor view一般是当前几面的底层容器（setContentView所设置的View的父容器，decor view是一个FrameLayout），通过Activity.getWindow().getDecorView()可以获得。现在，事件传递到decorView了，decorView再将事件传递给LinerLayout，LinerLayout将事件传递给Button。</p>
<p>这里要补充的是：当父容器通过 dispatchTouchEvent来传递事件时，如果他的onInterceptTouchEvent函数返回true，就不会将事件传递个子view，当然Android的还提供了一种防止父容器阻断事件的机制：只要子View调用requestDisallowInterceptTouchEvent方法，就能保证子View一定能收到点击事件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[垃圾回收算法]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/la-ji-hui-shou-suan-fa/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/la-ji-hui-shou-suan-fa/">
        </link>
        <updated>2021-12-03T11:32:35.000Z</updated>
        <content type="html"><![CDATA[<p>标记—清除算法<br>
标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。</p>
<p>复制算法<br>
官方解答：复制算法是将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。</p>
<p>个人解释：主要原理将内存区域划分为a，b两部分，每次只使用其中的一块。当发生垃圾回收时，先将a部分中“存活”的对象复制到b部分，然后直接清除a部分内容。接着使用b部分进行对象存储。但是直接将可用内存分成两部分，可能造成内存区域分配不够或内存浪费问题。所以JVM使用Eden区和Servivor0、Servivor1区的划分方式，占比为8 1 1.每次JVM会使用Eden和一个Servivor区存储对象，然后再发生垃圾回收时，将存活的对象一次性复制到另一块Servivor区中，接着将Eden和使用过的Servivor区擦除<br>
一次性复制不满足时，就会启用逃生门，使用额外的内存区域去存储对象。</p>
<p>复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。复制时要遍历整个GCroots</p>
<p>标记—整理算法<br>
标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。</p>
<p>分代收集算法<br>
分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。</p>
<p>一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用复制算法。在老年代中，对象存活率高，因此选用标记—清除算法或标记—整理算法。</p>
<p>作者：力扣 (LeetCode)<br>
链接：https://leetcode-cn.com/leetbook/read/java-interview-highlights/en7epe/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android与互联网交互的三种方式]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/android-yu-hu-lian-wang-jiao-hu-de-san-chong-fang-shi/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/android-yu-hu-lian-wang-jiao-hu-de-san-chong-fang-shi/">
        </link>
        <updated>2021-12-02T04:24:52.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1638419606056.jpg" alt="" loading="lazy"></figure>
<p>Get和Post的对比<br>
用得最多的两个，当然要做下对比啦！<br>
<img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1638419616758.jpg" alt="" loading="lazy"><br>
GET：在请求的URL地址后以?的形式带上交给服务器的数据，多个数据之间以&amp;进行分隔， 但数据容量通常不能超过2K，比如:http://xxx?username=…&amp;pawd=…这种就是GET<br>
POST: 这个则可以在请求的实体内容中向服务器发送数据，传输没有数量限制<br>
另外要说一点，这两个玩意都是发送数据的，只是发送机制不一样，不要相信网上说的 &quot;GET获得服务器数据，POST向服务器发送数据&quot;!!另外GET安全性非常低，Post安全性较高， 但是执行效率却比Post方法好，一般查询的时候我们用GET，数据增删改的时候用POST！！</p>
<p>网络框架okhttp<br>
OkHttp 是一个默认高效的 HTTP 客户端：<br>
HTTP/2 支持允许对同一主机的所有请求共享一个套接字。<br>
连接池减少了请求延迟（如果 HTTP/2 不可用）。<br>
透明 GZIP 可缩小下载大小。<br>
响应缓存完全避免网络重复请求。</p>
<p>设置请求头<br>
Request request = new Request.Builder()<br>
.url(&quot;http://www.baidu.com&quot;)<br>
.header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)<br>
.addHeader(&quot;token&quot;, &quot;myToken&quot;)<br>
.build();</p>
<p>get同步请求<br>
public void getSyn(final String url) {<br>
new Thread(new Runnable() {<br>
@Override<br>
public void run() {<br>
try {<br>
//创建OkHttpClient对象<br>
OkHttpClient client = new OkHttpClient();<br>
//创建Request<br>
Request request = new Request.Builder()<br>
.url(url)//访问连接<br>
.get()<br>
.build();<br>
//创建Call对象<br>
Call call = client.newCall(request);<br>
//通过execute()方法获得请求响应的Response对象<br>
Response response = call.execute();<br>
if (response.isSuccessful()) {<br>
//处理网络请求的响应，处理UI需要在UI线程中处理<br>
//...<br>
}<br>
} catch (IOException e) {<br>
e.printStackTrace();<br>
}<br>
}<br>
}).start();<br>
}</p>
<p>get异步请求<br>
public void getAsyn(String url) {<br>
OkHttpClient client = new OkHttpClient();<br>
Request request = new Request.Builder().url(url).build();<br>
Call call = client.newCall(request);<br>
call.enqueue(new Callback() {<br>
@Override<br>
public void onFailure(Call call, IOException e) {<br>
//...<br>
}</p>
<pre><code>    @Override
    public void onResponse(Call call, Response response) throws IOException {
        if(response.isSuccessful()){
            String result = response.body().string();
            //处理UI需要切换到UI线程处理
        }
    }
});
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android主题颜色问题]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/android-zhu-ti-yan-se-wen-ti/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/android-zhu-ti-yan-se-wen-ti/">
        </link>
        <updated>2021-10-19T12:09:03.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C42516%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211019200943180.png" alt="image-20211019200943180" loading="lazy"></figure>
<p>Can't find ColorStateList from drawable resource ID #0x7f080085</p>
<p>解决方法</p>
<p>不能在 XML 中将 drawable 设置为 colorBackground</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[adb下载安装及使用]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/adb-xia-zai-an-zhuang-ji-shi-yong/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/adb-xia-zai-an-zhuang-ji-shi-yong/">
        </link>
        <updated>2021-06-11T13:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>今天碰到这样的一道题<br>
adb 是在Android开发中经常使用的工具，其中从模拟器上拉取文件到本地电脑上使用的命令是（）</p>
<p>https://blog.csdn.net/weixin_43927138/article/details/90477966<br>
链接里的博客详细描述了Android开发中adb的使用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中== 和 equals()]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/java-zhong-he-equals/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/java-zhong-he-equals/">
        </link>
        <updated>2021-05-31T05:58:42.000Z</updated>
        <content type="html"><![CDATA[<p>执行下列程序的输出结果为（      ）<br>
public class Test {<br>
public static void main(String[] args) {<br>
String s1 = &quot;HelloWorld&quot;;<br>
String s2 = new String(&quot;HelloWorld&quot;);<br>
if (s1 == s2) {<br>
System.out.println(&quot;s1 == s2&quot;);<br>
} else {<br>
System.out.println(&quot;s1 != s2&quot;);<br>
}<br>
if (s1.equals(s2)) {<br>
System.out.println(&quot;s1 equals s2&quot;);<br>
} else {<br>
System.out.println(&quot;s1 not equals s2&quot;);<br>
}<br>
}<br>
}</p>
<p>正确答案为<br>
s1 != s2<br>
s1 equals s2</p>
<figure data-type="image" tabindex="1"><img src="https://zzxzzxzzx123.github.io/zhang3.github.io//post-images/1622440786573.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 var that = this 为什么在小程序出现这么频繁]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/guan-yu-var-that-this-wei-shi-me-zai-xiao-cheng-xu-chu-xian-zhe-me-pin-fan/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/guan-yu-var-that-this-wei-shi-me-zai-xiao-cheng-xu-chu-xian-zhe-me-pin-fan/">
        </link>
        <updated>2021-05-28T14:53:44.000Z</updated>
        <summary type="html"><![CDATA[<p>我在一个小程序项目中看到一个注释//var that=this很重要<br>
一开始我有点不明白，因为这样只是在this.setData变化中变成that.setData<br>
所以在出现问题后才去找了为什么</p>
]]></summary>
        <content type="html"><![CDATA[<p>我在一个小程序项目中看到一个注释//var that=this很重要<br>
一开始我有点不明白，因为这样只是在this.setData变化中变成that.setData<br>
所以在出现问题后才去找了为什么</p>
<!-- more -->
<p>https://blog.csdn.net/qq_37032151/article/details/81432732<br>
这篇博客讲的很好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小程序性能优化]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/xiao-cheng-xu-xing-neng-you-hua/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/xiao-cheng-xu-xing-neng-you-hua/">
        </link>
        <updated>2021-05-23T15:25:56.000Z</updated>
        <content type="html"><![CDATA[<p>#启动加载优化<br>
在小程序启动时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。</p>
<p>初始化小程序环境是微信环境做的工作,我们只需要控制代码包大小，和通过一些相关的缓存策略控制，和资源控制，逻辑控制，分包加载控制来进行启动加载优化。</p>
<p>勾选开发者工具中， 上传时压缩代码（若采用wepy高级版本，自带压缩，请按官网文档采取点击）<br>
精简代码，去掉不必要的WXML结构和未使用的WXSS定义。<br>
减少在代码包中直接嵌入的资源文件。（比如全国地区库，微信有自带的，在没必要的时候，勿自用自己的库）</p>
<p>及时清理无用的资源（js文件、图片、demo页面等）<br>
压缩图片，使用适当的图片格式，减少本地图片数量等</p>
<p>如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可以采用分包加载的方式进行优化，分包加载初始化时只加载首评相关、高频访问的资源，其他的按需加载。<br>
提前做异步请求，页面最好在onLoad时异步请求数据，不要在onReady时请求<br>
启用缓存数据策略，请求时先展示缓存内容，让页面尽快展示，请求到最新数据之后再刷新<br>
避免白屏，使用骨架屏等</p>
<p>#数据通信优化<br>
为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：</p>
<p>不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；<br>
数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；<br>
与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。<br>
提升数据更新性能方式的代码示例：</p>
<p>Page({<br>
onShow: function() {</p>
<pre><code>// 不要频繁调用setData
this.setData({ a: 1 })
this.setData({ b: 2 })
// 绝大多数时候可优化为
this.setData({ a: 1, b: 2 })

// 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外
this.setData({
  myData: {
    a: '这个字符串在WXML中用到了',
    b: '这个字符串未在WXML中用到，而且它很长…………………………'
  }
})
// 可以优化为
this.setData({
  'myData.a': '这个字符串在WXML中用到了'
})
this._myData = {
  b: '这个字符串未在WXML中用到，而且它很长…………………………'
}
</code></pre>
<p>}<br>
})<br>
#事件通信优化<br>
视图层会接受用户事件，如点击事件、触摸事件等。当一个用户事件被触发且有相关的事件监听器需要被触发时，视图层会将信息反馈给逻辑层。这个反馈是异步的，会产生延迟，降低延迟的方法有两个：</p>
<p>去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；<br>
事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。</p>
<p>#渲染优化<br>
页面方法onPageScroll使用， 每次页面滚动都会触发，避免在里面写过于复杂的逻辑 ，特别是一些执行重渲染页面的逻辑<br>
在进行视图重渲染的时候，会进行当前节点树与新节点树的比较，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决tabbar页面跳转的问题]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/jie-jue-tabbar-ye-mian-tiao-zhuan-de-wen-ti/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/jie-jue-tabbar-ye-mian-tiao-zhuan-de-wen-ti/">
        </link>
        <updated>2021-05-23T13:14:21.000Z</updated>
        <summary type="html"><![CDATA[<p>wx.navigateTo是我们常用的跳转页面方法，那有没有在开发中碰到这个情况呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>wx.navigateTo是我们常用的跳转页面方法，那有没有在开发中碰到这个情况呢？</p>
<!-- more -->
<p>wx.navigateTo(Object object)<br>
保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。</p>
<p>那当我们在tabbar页面已经有跳转了后，再使用wx.navigateTo时就会碰到问题</p>
<p>这种情况下我们可以使用这个方法 wx.switchTab(Object object)<br>
其功能为跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于.ipynb文件]]></title>
        <id>https://zzxzzxzzx123.github.io/zhang3.github.io/post/guan-yu-ipynb-wen-jian/</id>
        <link href="https://zzxzzxzzx123.github.io/zhang3.github.io/post/guan-yu-ipynb-wen-jian/">
        </link>
        <updated>2021-05-12T14:15:15.000Z</updated>
        <summary type="html"><![CDATA[<p>一、简介：</p>
<p>.ipynb文件即为Jupyter Notebook，是一个交互式笔记本，支持运行 40 多种编程语言。</p>
<p>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。它的主要用途是：数据清理和转换，数值模拟，统计建模，机器学习等，Jupyter Notebook 与 IPython终端 共享同一个内核。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一、简介：</p>
<p>.ipynb文件即为Jupyter Notebook，是一个交互式笔记本，支持运行 40 多种编程语言。</p>
<p>Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。它的主要用途是：数据清理和转换，数值模拟，统计建模，机器学习等，Jupyter Notebook 与 IPython终端 共享同一个内核。</p>
<!-- more -->
<p>二、如何在windows下打开一个.ipynb文件<br>
　　1、使用pip安装jupyter</p>
<p>pip install jupyter<br>
　<br>
　　2、使用命令进入web程序界面<br>
　　在命令行输入：</p>
<p>jupyter notebook</p>
<p>3、找到.ipynb文件，点击打开</p>
<p></p>
<p></p>
]]></content>
    </entry>
</feed>